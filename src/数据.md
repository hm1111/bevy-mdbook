### 介绍-你的数据

ECS的数据结果被称为`World`。World用来存储和管理所有数据。在高级情形下，还可能存在多个`World`，但是通常情况下，你只需要一个主`World`就可以了。

你可以使用2中方式来表示你的数据：`Entities/Components`和`Resouces`

### Entities/Components

你可以认为有这样一张表：表的列表示`Component`；行表示每一个`Entity`。`Entity`的ID就是行的编号，通过编号能够找到特定组件的值。

`marker components`（不包含数据的`component`）通常被用来标识一个特定的`entity`。

![](../_resources/2024-08-19-21-05-05-image.png)

一个显而易见的模式是使用`entity`来表达"游戏/场景中的对象"。
Bevy会自动追踪`systems`访问的数据，并在多核CPU上并行运行。

Bevy不能改变内存布局因为其他`systems`可能在运行，因此，若想创建/移除`entity`或`components`，可以使用`Commands`来缓存/延迟这些操作，Bevy会在确保安全的情况下执行它们。若想立刻执行这些操作，可访问[exclusive systems]()和[direct World access]()进行查看。

`Bundle`像是一个一组常用组件的模板，在你想创建一些`entities`，不会忘记其他的东西。

### 和面向对象思想的比较

在面向对象思想中，所有事物都被看做“对象”，所有对象都是类的一个实例，类中定义了所需的所有数据和行为，因此，同一类的所有对象都有着相似的数据和行为。

在ECS思想中，`entity`可以包含任何数据，`entity`的目的就是标记这些数据，`systems`是操作数据的一系列方法，它们可以很轻松地找到所需要的数据，并实现期望的行为。

如果数据经常被一起访问,你应该把他们放进一个单独的`struct`. 例如,bevy的`Transform`和`Color`。这种方式适用于字段不会被独立使用的场景。相反，当不同的数据片段可能需要独立访问时，你应该使它们更加细化。

组成`entity`的`component`集合/组合被称为`entity`的原型.Bevy会在内部跟踪他们,以组织RAM中的数据。具有相同原型的`entity`的数据被存储在一起,这允许CPU高效地访问和缓存这些数据。

如果你在已存在的`entity`上增加/移除`component`,你就在修改原型,可能会使Bevy复制数据到其他位置。

[有关Bevy的component存储的更多信息]()

`Entity` IDs是可重复使用的。`Entity`实际上有两个整型数字:ID和 "generation". 你销毁一些`entity`后,它们的ID可以被重新用于新生成的`entity`,但是bevy会自增它们的generation。

### Resources

如果某个东西是全局唯一的(单例),而且它不与其他数据关联,使用`Resource`。

