# 5.7. 固定时间步

如果你需要以固定的速率运行某些系统，而不受显示帧率的影响，Bevy 提供了一个解决方案。

每帧更新时，Bevy 都会根据需要多次运行 `FixedUpdate` shedule，以追赶进度。如果游戏运行缓慢，它可能会运行多次。如果游戏运行快速，它可能会被跳过。

默认的固定时间步帧率是64Hz。这个帧率可被修改。

## 检查时间

在Bevy游戏引擎中，你可以使用`Res<Time>`资源来访问当前的时间信息。当你的系统在`FixedUpdate`中运行时，Bevy会自动检测到这一点，并且所有的时间信息（如时间间隔delta）将代表固定的时间步长，而不是显示的帧率。

如果你需要从一个在固定时间步之外运行的系统中访问固定时间步时间，你可以使用 `Res<Time<Fixed>>` 代替。

如果你需要从一个在固定时间步下运行的系统访问常规帧时间，你可以使用 `Res<Time<Virtual>>` 代替。`Res<Time<Real>>` 提供给你真实的（墙上时钟）时间，没有暂停或缩放。

## Update or FixedUpdate

固定时间步的目的是使游戏代码的行为可预测且可靠。物理和模拟等工作如果以固定的时间间隔计算效果最佳，因为这样可以避免浮点错误的积累和帧率变化导致的不稳定行为。

一些应该在`FixedUpdate`下运行的系统包括：

1. 物理和碰撞检测；

2. 网络；

3. 敌人AI和NPC AI；

4. 生成/销毁游戏玩法相关的实体；

5. 其他的模拟和决策制定；

然而，任何直接影响屏幕显示的内容都应该每帧运行，以使其看起来平滑。如果你在固定时间步长下进行移动或动画，它看起来会很不连贯，尤其是在高刷新率的屏幕上。

一些应该在`Update`下运行的系统包括：

1. 相机运动和控制；

2. 动画；

3. UI；

4. 视觉效果；

5. 任何属于游戏图形/视觉效果或交互性的部分；

6. 应用程序状态转换；

玩家的移动和其他属于游戏玩法的移动应该在`FixedUpdate`中完成，这样可以确保它工作的可靠性和一致性。为了使其在屏幕上看起来也平滑，请参见关于[变换插值/外推](./transiton_interpolation_and_extrapolation.md)的部分。

## 输入处理

在固定时间步长（FixedUpdate）中使用 `Res<ButtonInput<...>>` 和 `.just_pressed/.just_released` 来检查按键或按钮状态可能会遇到问题，因为这些状态是每帧更新一次的，在 `FixedUpdate` 中使用可能不可靠。
为了解决这个问题，建议使用事件（events）来处理输入，或者自己实现一套输入处理逻辑。

具体做法是将输入处理系统放在 `PreUpdate` shedule中，确保它们在 Bevy 的输入系统之后运行，然后在这个阶段进行输入处理，并将其转换为自定义事件类型或其他有用的表示形式，以便在 `FixedUpdate` 中处理游戏逻辑时使用。

## 时间上需要注意的事项

固定时间步长不是按现实世界的时间运行的！你不能依赖它来计时！

例如，如果你试图从它那里播放音频，或发送网络数据包，你会注意到它们实际上并不是按固定时间步长间隔发生的。

你的系统仍然是作为常规帧更新周期的一部分被调用的。每一帧更新时，Bevy都会根据需要运行`FixedMain` shedule多次，以追赶进度。

这意味着，例如，如果你指定一个60Hz的固定时间步长间隔，你的系统实际上不会在现实时间中以1/60秒的间隔运行。

1. 如果显示的帧率比时间步长快，一些帧更新周期将完全跳过`FixedMain` shedule。 

2. 如果显示的帧率比时间步长慢，一些帧更新周期将多次运行`FixedMain`。 

在任何情况下，`FixedMain`将在`Update`之前运行，而`Update`是你每帧都需要运行的系统的所在之处。

## 额外的shedules

`FixedMain`不仅包含了`FixedUpdate`，还包含了其他的shedule：

1. `FixedFirst`

2. `FixedPreUpdate`

3. `FixedUpdate`

4. `FixedPostUpdate`

5. `FixedLast`